"""Main CLI entry point for Lua2C++ transpiler"""

import sys
import argparse
import re
import traceback
from pathlib import Path
from typing import List, Set, Optional, Dict, Tuple

try:
    from luaparser import ast
    from luaparser.ast import SyntaxException
except ImportError:
    print("Error: luaparser is required. Install with: pip install luaparser", file=sys.stderr)
    sys.exit(1)

from lua2cpp.generators import CppEmitter
from lua2cpp.generators.header_generator import HeaderGenerator
from lua2cpp.core.library_call_collector import LibraryCallCollector, LibraryCallCollector as Collector


def transpile_file(input_file: Path, collect_library_calls: bool = False, output_dir: Optional[Path] = None, verbose: bool = False) -> Tuple[str, List, Optional[Collector]]:
    """Transpile a single Lua file to C++

    Args:
        input_file: Path to Lua source file
        collect_library_calls: If True, also collect library calls for header generation
        output_dir: Optional output directory for generated files
        verbose: If True, print verbose file generation details

    Returns:
        Tuple of (generated C++ code, list of LibraryCall objects if collect_library_calls=True else [])

    Raises:
        FileNotFoundError: If input_file doesn't exist
        PermissionError: If input_file cannot be read
        SyntaxException: If Lua source has invalid syntax
        Exception: If code generation fails
    """
    if not input_file.exists():
        raise FileNotFoundError(f"Input file not found: {input_file}")

    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            source = f.read()
    except PermissionError as e:
        raise PermissionError(f"Cannot read input file {input_file}: {e}")

    try:
        tree = ast.parse(source)
    except SyntaxException as e:
        raise SyntaxException(f"Invalid Lua syntax in {input_file}: {e}")

    # Collect library calls if requested
    library_calls = []
    collector = None
    if collect_library_calls:
        collector = LibraryCallCollector()
        collector.visit(tree)
        library_calls = collector.get_library_calls()

    emitter = CppEmitter()
    cpp_code = emitter.generate_file(tree, input_file)

    return cpp_code, library_calls, collector


def extract_function_signatures(cpp_code: str) -> List[str]:
    """Extract function signatures from generated C++ code using regex.

    Simple approach: extract function definitions and convert to forward declarations.
    Pattern: return_type function_name(params) { ... }

    Args:
        cpp_code: Generated C++ source code

    Returns:
        List of function signatures (return_type function_name(params))
    """
    signatures = []

    # Pattern to match function definitions
    # Matches: return_type function_name(params) {
    # Excludes: static functions (not exported), comments, preprocessor directives
    pattern = r'^([a-zA-Z_][a-zA-Z0-9_<>:*&\s]+)\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)\s*\{'

    for line in cpp_code.split('\n'):
        line = line.strip()

        # Skip empty lines, comments, and preprocessor directives
        if not line or line.startswith('//') or line.startswith('/*') or line.startswith('#'):
            continue

        # Skip static functions (not exported)
        if 'static' in line:
            continue

        match = re.match(pattern, line)
        if match:
            return_type = match.group(1).strip()
            func_name = match.group(2).strip()
            params = match.group(3).strip()

            signature = f"{return_type} {func_name}({params})"
            signatures.append(signature)

    return signatures


def generate_lib_header(cpp_code: str, module_name: str) -> str:
    """Generate .hpp header file with forward declarations.

    Args:
        cpp_code: Generated C++ source code
        module_name: Name of the module (input filename stem)

    Returns:
        Header file content with forward declarations
    """
    signatures = extract_function_signatures(cpp_code)

    header_lines = [
        f'// Auto-generated header for {module_name}',
        f'// Generated by lua2cpp',
        '',
        '#pragma once',
        '',
    ]

    for sig in signatures:
        header_lines.append(f'{sig};')

    header_lines.append('')

    return '\n'.join(header_lines)


def main():
    """Main entry point for the CLI."""
    parser = argparse.ArgumentParser(
        description="Transpile Lua 5.4 source code to C++"
    )
    parser.add_argument(
        "input",
        type=Path,
        help="Input Lua file to transpile"
    )
    parser.add_argument(
        "-o", "--output",
        type=Path,
        help="Output C++ file"
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=Path("."),
        help="Output directory for generated files"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Print verbose file generation details"
    )
    parser.add_argument(
        "--header",
        action="store_true",
        help="Generate state.h header file with library API declarations"
    )
    parser.add_argument(
        "--lib",
        action="store_true",
        help="Generate as library (output {input_name}.hpp with forward declarations)"
    )

    args = parser.parse_args()

    try:
        args.output_dir.mkdir(parents=True, exist_ok=True)
    except PermissionError as e:
        print(f"Error: Permission denied when creating output directory {args.output_dir}: {e}", file=sys.stderr)
        sys.exit(1)
    except OSError as e:
        print(f"Error: Cannot create output directory {args.output_dir}: {e}", file=sys.stderr)
        sys.exit(1)

    try:
        cpp_code, library_calls, collector = transpile_file(args.input, collect_library_calls=args.header, output_dir=args.output_dir, verbose=args.verbose)
    except FileNotFoundError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except PermissionError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except SyntaxException as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error transpiling {args.input}:", file=sys.stderr)
        traceback.print_exc()
        sys.exit(1)

    if args.output:
        output_file = args.output_dir / args.output
    else:
        output_file = args.output_dir / f"{args.input.stem}.cpp"

    if args.verbose:
        print(f"Transpiling: {args.input} â†’ {output_file}")

    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(cpp_code)
    except PermissionError as e:
        print(f"Error: Permission denied when writing to {output_file}: {e}", file=sys.stderr)
        sys.exit(1)
    except OSError as e:
        print(f"Error writing output file {output_file}: {e}", file=sys.stderr)
        traceback.print_exc()
        sys.exit(1)

    print(f"Generated: {output_file}")

    if args.lib:
        try:
            hpp_content = generate_lib_header(cpp_code, args.input.stem)
            hpp_file = output_file.parent / f"{args.input.stem}.hpp"
            with open(hpp_file, 'w', encoding='utf-8') as f:
                f.write(hpp_content)
            print(f"Generated: {hpp_file}")
        except Exception as e:
            print(f"Error generating library header file: {e}", file=sys.stderr)
            traceback.print_exc()
            sys.exit(1)

    if args.header:
        try:
            header_gen = HeaderGenerator()
            global_functions = set()
            if collector:
                for call in collector.get_global_calls():
                    global_functions.add(call.func)
            state_h_content = header_gen.generate_header(library_calls, global_functions)

            state_h_path = output_file.parent / "state.h"
            with open(state_h_path, 'w', encoding='utf-8') as f:
                f.write(state_h_content)

            print(f"Generated: {state_h_path}")
        except Exception as e:
            print(f"Error generating header file: {e}", file=sys.stderr)
            traceback.print_exc()
            sys.exit(1)


if __name__ == "__main__":
    main()
